# 컴넷 09.15



## 서론

physical layer가 왼쪽과 오를쪽을 연결하면 이를 에러검출하고 복구하는게 2계층의 역할이다. 그리고 mac 계층에서는 physical한 medium을 어떻게 하면 효율적으로 공유할 수 있는지를 배운다. Data link control 은 physical layer를 어떻게 에러를 검출하고 복구하는지에 대해 배운다.

## DLC Basic

Data Link Control 은 OSI 7 Layer 의 2계층 영역이다. DLC는 Message를 Frame , Packet에 포장하는 Framing, Message의 Error 검출과 복구, Flow control을 수행한다. MAC Layer에서 Medium에 직접 연결되고 Message를 보내는 과정을 수행한다면  그 이전에  DLC 에서 Framing 과정으로 Message 를 만든다  이때 왼쪽과 오른쪽의 장비에 성능 문제로 통신이 안될 수 있으니 DLC의 Flow control로 Message 전송 속도를 제어해야 한다. 

- Framing
  Framing은 편지를 보내는 과정과 유사하다. 3계층에서 내려온 Data를 보낼 수 있는 크기로 나누고 송신단의 Source address 수신단의 Destination address를 담는다. 그리고 Error 검출과 복구를 수행할 수 있는 정보를 담는다. 

  - A frame in a character-oriented protocol

    Message를 보내는 것은 0과 1 이 전송되는 것이다. 이때 Charater 타입으로 하는 것이 Character-oriented protocol 이라 한다. 

    Flag - Header - - Trailer - Flag

    1. Flag 

       Physical layer끼리는 Message를 보내지 않더라도 끊임없이 Training 하고 있다. 이는 송수신단에서 0과 1을 구별하기 위해 그 기준 값을 가지기 위해서다.  Flag 는 Message 가장 앞뒤에 달려있어서 Training 을 그만하고 이제 부터 Message 가 도착한다는 것을 알리고 Message를 다 보냈음을 알리는 역할이다. 

    2. Header & Trailer 

       3계층에서 보내고 싶은 Data가 내려오면 필요할 경우 Header와 Trailer를 붙인다. 

       

  - Byte stuffing and unstuffing

    Byte stuffing and unstuffing 은 Byte 단위를 썼다는 것이다. 따라서 Character data type 으로 처리했다는 것이다. 

    1. Stuffing 

       ESC(escape sequence) 라는 특수 코드를 Data 사이에 삽입하는 과정이다. 이는 3계층에서 내려온 Data가 Flag와 동일한 Code가 있을 경우 이를 구별해주기 위해서다. 이는 ESC + Flag 로 만들어주고 ESC Code 와 동일한 Data도 있을 수 있으므로 ESC + ESC 로 만들어준다. 

    2. Unstuffing 

       ESC를 빼는 과정이다.

    

  - Bit stuffing and unstuffing

    프로그래밍을 할때 Data를 Bit 단위로 처리하겠다는 것이다.

    1. Stuffing 

       Bit stuffing 은 두가지 역할을 한다. 첫번째는 Flag와 동일한 Code를 구별하는 기능을 수행한다. 두번째는 1 x 5 다음 0 을 집어넣는다. 

    2. Unstuffing

       Flag를 구별하는 Code를 제거한다. 1 x 5 다음 0을 제거한다.

    - Bit 단위를 사용한 이유 

      과거엔 느린 통신조자 가격이 비쌌다. 비산 통신 Link 를 최대한 효율적으로 사용하고자 Bit 단위를 사용했다. 

    | ---------- 작업중 ------------|

- flow and Error Control

  2 계층 이상인 구조에서는 보내는쪽과 받는 쪽에서 끊임없이 피드백을 한다. 피드백 내용은 데이터 전송 속도 제어 같은 것이다.

  - Connection : Physcial layer는 서로가 연결되어 있지만 2계층 이상은 실재로 연결되어 있진 않다. 이부분은 소프트웨어적인 로직이다. 이런 논리적인 연결, 가상의 연결 방법으로, Connection을 만들어 놓고 통신할지 말지를 결정한다. Connection oriented 라면 데이터를 주고받기전에 Connection 을 만든다. 그리고 통신을 주고 받았다면 Connection을 끊는다. 연결설정, 연결유지, 연결해지라는 과정을 다 가지고 있다. Connection less라면 상대방을 고려하지 않는다. 데이터를 주고 받는건 당연한데 데이터를 주고 받기 전에 연결설정을 하고 데이터를 주고 받으면서 연결을 유지하고 다 주고받았다면 연결을 해지하는 Connection oriented 를 할건지, 아무것도 하지않는 Connection less를 할지 결정한다. 이후에 Flow control과 Error control은 대부분 Connection oriented에서 하는 경우가 많다. connection less를 거의 하지는 않지만 않하는 경우가 많다.

## Simple Protocol

자연계에선 존재할 수 없는 방법이다. 이것은 이후의 방식을 설명하기 위한 방법이다.

- Simple Protocol : Flow 컨트롤 에러 컨트롤을 하지 않는다. 왼쪽과 오른쪽의 수신과 송신하는 곳이 있을 때, Logical 한 link를 통해서 receving node에 데이터를 전송하고 받는다. 그리고 어떠한 속도 차이도 없고 에러도 없다는 것이다. 그래서 자연계에서 존재할 수 없다.

<img src="img/2021-09-20-00-42-58.png" width="400" height="100">

- FSM(finite state machine) for the simple Protocol : 상태천이도로 그림으로 표현되어 있다. 우리가 아래 사진에서 봐야 할 것은 두줄의 문장이다. Packet came from network layer. -> make a frame and send it 패킷으로 만들고 프레임을 만들어 보낸다. Sending node 에서 Receving node 로 보낸다. 이때 보내는 통로는 physical layer. 보내고 난 다음 receving node는 받는데, 받고 나면 다시 ready 상태로 가서 sending 하길 기다린다. 상태천이도로 그려지는걸 finite state machine 이라 한다.

<img src="img/2021-09-17-15-47-48.png" width="400" height="300">

- message sequence chart
  ![](2021-09-20-00-47-10.png)
  화살표가 아래로 내려가있는 것은 sending node의 data link에서 보내는데 시간이 걸린다는 의미다.

## Stop and wait Protocol

simple 처럼 하려고 하니 당연 error 가 생긴다. 그래서 에러 검출을 해서 복구한 경우가 생겼다. 그것이 Stop and wait protocol 이다.

- stop and wait

  에러 제어 및 흐름 제어 기법이다. 에러가 났다는 것을 아는 것이 중요하다. 에러가 난지 확인 하는 방법은, 전송할 데이터 외에 추가적인 정보를 보내서 그 값이 온전히 왔는지 확인한다. 두번째로 송신 한 쪽에서 무언갈 쐈는데 아무것도 수신쪽에 도착하지 않았다면, 즉 메시지가 사라졌다면 응답 시간으로 에러를 정의한다. 이걸 고치는게 에러 컨트롤이다.
  ![](img/2021-09-20-00-53-32.png)

  CRC라는 코드가 추가됨을 확인하자. sending node 에서 frame 을 보낼 때 CRC코드가 섞여서 간다. Receving node에 도착한 후 여기서 Frame을 깐다. 그리고 같이 CRC코드값을 해독한다. 그래서 다시 도로 Sending node에 ACK + CRC를 sending node에 보낸다. ACK 메시지도 엄연히 데이터가 있다. 이렇게 Sending node는 frame 이 잘 갔구나를 알 수 있다. 이것이 Stop and wait 동작 개요다. ACK는 정상적인 CRC임을 확인 했을 때만 ACK 메시지를 보낸다.

  - 메시지가 도착은 했으나 변질된 경우

    sending node는 ACK메시지를 받지 못한다. 이걸 타이머로 시간을 측정해서 결정한다. 이후 Sending node 는 k 번 재전송 한다.

  - 메시지가 사라진 경우

    결국 ACK 메시지를 보낼 수 없으니 Sending node 에 timer가 터진다.

  - stop and wait 의 상태천이도

    ![](img/2021-09-20-01-03-39.png)

  - stop and wait의 문제

    ![](img/2021-09-20-01-07-49.png)

    3번째 경우를 보면 ACK가 사라진 경우다. 그래서 Duplicate된 packet이 Network에 올라간다.

    해결방법 : Frame에 0 ,1 으로만 numbering 해서 보낸다. 그렇게 해서 위에 문제 상황에서 1이 와야할 때 0 이오면 아, duplicate 되었구나 확인 .

- Piggybacking

  내가 보낼게 있고 받을 게 있다면, 굳이 ACK메시지를 보내야하나. 내가 보낼 메시지에 같이 실어서 보낼게.

## Go - Back - N Protocol

더 많은 데이터를 짧은 interval로 보내기 시작하면서, 가만히 있는 시간도 사용해야 한다.

- Send window for go - back - N ARQ

  ACK가 안오더라도 여러개의 메시지를 보낼 수 있다.

  window : 메시지를 여러개 보낼 수 있는 Range 이다. Circular ring 형태이다. size = 2^m - 1 을 유지한다.

  outstanding stance : 쐈는데 응답이 안온 것이다. 그때의 첫번 째 응답을
  Sf라 칭한다. 그리고 Sn도 유지한다. Sf에 해당하는 메시지에 응답이 왔을 경우 Sf는 이동하고 Window size 도 유지하기 위해 slide 한다.

  - window size 가 2^m-1 인 이유
    2^m 일 경우 ACK가 오지 않은 상황일 때 에러가 있는 상태에서 Receiver는 0을 기다리고 있는데 Sender가 0 을 전송한다.
    하지만 2^m-1 일 경우 Receiver 가 3을 기다릴때 Sender 가 0을 전송해서 Receiver가 Error임을 확인 할 수 있다. 그래서 그
    때 Receiver는 받은 Frame을 그냥 버린다.

- Selective Repeat Protocol

  Go back N의 단점을 Error 검출 방법이 ACK나 FRAME의 전송 유무로 확인하므로 만일 Error가 발생할 경우 뒤따라 전송되는 Frame 들은 Receiver가 다 버려버린다. 여기서 효율성을 높여보자.

  - 2^(m-1)

    2^m -1 이 아니다.

  - Receiver window for selective Repeat

    Receiver가 여러개의 Buffer를 가질 수 있다. 따라서 선택적 재전송이란 선택적으로 Error가 발생한 buffer만 error이라 하겠다.

  - ACK, NAK

    NAK : 1을 보냈는데, 도착하지 않았는데 2가 도착했다. 그러면 NAK1을 전송한다. 그때 3이 도착하면 버리지 않고 받는다.

- DLC Example - HDLC

  HDLC(High-level Data Link Control). 2계층 위에 Application level 이 바로 올라간 경우이다. 전화선으로 정보를 주고받는 것이다.

  - HDLC Frames

    I frame, S frame, U frame.

- DLC Example - PPP

  3계층 이상의 Application을 유지관리한다. PPP는 이 사용자가 합법적인지, 얼마만큼의 지원을 받으면 되는지, 암호화하는지 관리한다. 따라서 상위 계층의 Ip/ protocol를 관리하기 때문에 Error 검출 및 복구의 기능은 크게 없다.

  - Frame Format

  - Tramsition phase
